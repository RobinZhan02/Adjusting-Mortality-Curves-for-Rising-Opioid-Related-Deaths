---
title: "Missing Data Infer"
output: html_document
---

```{r, warning=FALSE}
rm(list=ls());gc()
library(tidyverse)
library(lpSolve)
library(data.table)
library(lubridate) 
```
# load and check the data
```{r}
file_list <- list.files("data_for_infer")

# constants
n_years   <- 22
n_months  <- 12
n_age_10  <- 12
n_age_5   <- 23
n_div     <- 9
n_region  <- 4
n_sex     <- 2

# helper to compute expected row count from file name
expected_rows_for_file <- function(fname) {
  # age groups: assume files without "5Yr" or "10Yr" are not age-stratified (age factor = 1)
  age_factor <- if (str_detect(fname, fixed("5Yr"))) {
    n_age_5
  } else if (str_detect(fname, fixed("10Yr"))) {
    n_age_10
  } else {
    1L
  }
  # geography: exactly one of Division or Region; otherwise fallback to 1
  geo_factor <- if (str_detect(fname, fixed("Census Division"))) {
    n_div
  } else if (str_detect(fname, fixed("Census Region"))) {
    n_region
  } else {
    1L
  }
  # sex: 2 if "Sex" mentioned, else 1
  sex_factor <- if (str_detect(fname, fixed("Sex"))) n_sex else 1L

  age_factor * geo_factor * sex_factor * n_months * n_years
}

# containers
row_checks <- list()
data <- tibble()

# main loop
for (i in file_list) {
  # read
  tmp <- fread(paste0("data_for_infer/", i))

  # filter Month Code present
  tmp <- tmp |>
    filter(!is.na(`Month Code`)) |>
    # coerce every column to character but keep NA as NA (not "NA")
    mutate(across(everything(), ~ ifelse(is.na(.x), NA_character_, as.character(.x))))

  # bind
  data <- bind_rows(data, tmp)

  # check counts
  observed <- nrow(tmp)
  expected <- expected_rows_for_file(i)

  row_checks[[length(row_checks) + 1]] <- tibble(
    file     = i,
    expected = expected,
    observed = observed,
    matches  = observed == expected
  )
}

# summarize checks
row_checks <- bind_rows(row_checks) |> arrange(matches, file)

# print only mismatches with a clear message
mismatches <- row_checks |> filter(!matches)
if (nrow(mismatches) == 0) {
  message("All files match expected row counts.")
} else {
  message("The following files do not match expected row counts:")
  print(mismatches, n = Inf)
}

rm(tmp, row_checks, mismatches);gc()
```
# Prepare Data for Analysis
```{r}
data_prepared <- data |> select(`Census Division Code`, `Census Region Code`, `Month Code`,`Sex Code`, `Age Group Code`, `Ten-Year Age Groups Code`, `Five-Year Age Groups Code`, `Deaths`) |>
  mutate(`Age Group Code` = case_when(!is.na(`Ten-Year Age Groups Code`) ~ `Ten-Year Age Groups Code`,
                                      !is.na(`Five-Year Age Groups Code`) ~ `Five-Year Age Groups Code`,
                                      T ~ `Age Group Code`)) |>
  select(-`Ten-Year Age Groups Code`, -`Five-Year Age Groups Code`) |> unique()
rm(data);gc()
```

# Load the Code for later mapping
```{r}
Census_Region_Code <- read_csv("Census-Region_Code.csv", show_col_types = F)
Census_Division_Code <- read_csv("Census-Division_Code.csv", show_col_types = F)
Age_Group_Code <- read_csv("Age Group_Code.csv", show_col_types = F)
```

```{r}
infer_suppressed_iterative <- function(data_prepared,
                                       max_region_iter = 20,
                                       max_division_iter = 20) {

  ## ---------- Prep ----------
  dt <- as.data.table(data_prepared)

  if (!"Deaths" %in% names(dt)) {
    stop("Input must contain 'Deaths'.")
  }

  dt[, row_id := .I]
  dt[, is_suppressed_orig := Deaths == "Suppressed"]

  suppressWarnings(
    dt[, Deaths_num := as.numeric(Deaths)]
  )
  dt[, current_val := Deaths_num]

  # exactly one of region/division per row
  dt[, geo_type := fifelse(!is.na(`Census Division Code`), "division",
                    fifelse(!is.na(`Census Region Code`), "region", NA_character_))]
  dt[, geo_code := fifelse(geo_type == "division", `Census Division Code`,
                     fifelse(geo_type == "region", `Census Region Code`, NA_character_))]

  # mapping region <-> divisions (adjust to actual codes if different)
  div_to_region <- data.table(
    division_code = c("CENS-D1","CENS-D2","CENS-D3","CENS-D4","CENS-D5",
                      "CENS-D6","CENS-D7","CENS-D8","CENS-D9"),
    region_code   = c("CENS-R1","CENS-R1","CENS-R2","CENS-R2","CENS-R3",
                      "CENS-R3","CENS-R3","CENS-R4","CENS-R4")
  )
  region_to_divs <- split(div_to_region$division_code, div_to_region$region_code)

  # 10-year bands as unions of 5-year bands (critically, no "1" here)
  age_10_to_5 <- list(
    "5-14"  = c("5-9", "10-14"),
    "15-24" = c("15-19", "20-24"),
    "25-34" = c("25-29", "30-34"),
    "35-44" = c("35-39", "40-44"),
    "45-54" = c("45-49", "50-54"),
    "55-64" = c("55-59", "60-64"),
    "65-74" = c("65-69", "70-74"),
    "75-84" = c("75-79", "80-84"),
    "85+"   = c("85-89", "90-94", "95-99", "100+")
  )

  # rows that cannot be inferred via our direct rules
  dt[, is_impossible := FALSE]

  ## ---------- Helpers ----------

  is_unknown_now <- function() {
    dt$is_suppressed_orig & is.na(dt$current_val) & !dt$is_impossible
  }

  try_set <- function(idx, candidate) {
    if (length(idx) != 1L || is.na(idx)) return(FALSE)
    if (is.na(candidate)) return(FALSE)
    if (candidate < 1L || candidate > 9L) return(FALSE)
    if (abs(candidate - round(candidate)) > 1e-9) return(FALSE)
    if (!dt$is_suppressed_orig[idx]) return(FALSE)
    if (!is.na(dt$current_val[idx])) return(FALSE)
    if (dt$is_impossible[idx]) return(FALSE)
    dt[idx, current_val := as.integer(round(candidate))]
    TRUE
  }

  ## ---------- Rule: Sex totals (Tot = F + M) ----------
  # Sex Code NA => not grouped by sex => total for that slice.

  deduce_sex_from_total <- function(geo_filter = NULL) {
    dt[, is_unknown := is_unknown_now()]

    gdt <- dt[
      is_impossible == FALSE &
      (is.na(`Sex Code`) | `Sex Code` %chin% c("F", "M"))
    ]
    if (!is.null(geo_filter)) gdt <- gdt[geo_type == geo_filter]
    if (!NROW(gdt)) { dt[, is_unknown := NULL]; return(0L) }

    keys <- c("Month Code", "geo_type", "geo_code", "Age Group Code")
    sumdt <- gdt[, .(
      has_tot = any(is.na(`Sex Code`)),
      has_F   = any(`Sex Code` == "F"),
      has_M   = any(`Sex Code` == "M")
    ), by = keys]

    cand <- sumdt[has_tot == TRUE & has_F == TRUE & has_M == TRUE]
    if (!NROW(cand)) { dt[, is_unknown := NULL]; return(0L) }

    setkeyv(gdt, keys)
    new_count <- 0L

    for (i in seq_len(nrow(cand))) {
      key_row <- cand[i]
      rows <- gdt[key_row, on = keys, nomatch = 0]

      tot_row <- rows[is.na(`Sex Code`)]
      F_row   <- rows[`Sex Code` == "F"]
      M_row   <- rows[`Sex Code` == "M"]
      if (nrow(tot_row) != 1L || nrow(F_row) != 1L || nrow(M_row) != 1L) next

      ids  <- c(tot_row$row_id, F_row$row_id, M_row$row_id)
      vals <- dt$current_val[ids]
      unks <- dt$is_unknown[ids]

      if (sum(unks) != 1L) next
      if (any(!unks & is.na(vals))) next

      unk_id <- ids[unks]

      if (unk_id == ids[1]) {
        candidate <- vals[2] + vals[3]
      } else if (unk_id == ids[2]) {
        candidate <- vals[1] - vals[3]
      } else {
        candidate <- vals[1] - vals[2]
      }

      if (try_set(unk_id, candidate)) new_count <- new_count + 1L
    }

    dt[, is_unknown := NULL]
    new_count
  }

  ## ---------- Rule: Age totals (NA Age = total over ages) ----------

  deduce_age_total <- function(geo_filter = NULL) {
    dt[, is_unknown := is_unknown_now()]

    gdt <- dt[is_impossible == FALSE]
    if (!is.null(geo_filter)) gdt <- gdt[geo_type == geo_filter]
    if (!NROW(gdt)) { dt[, is_unknown := NULL]; return(0L) }

    keys <- c("Month Code", "geo_type", "geo_code", "Sex Code")
    sumdt <- gdt[, .(
      has_total = any(is.na(`Age Group Code`) & !is.na(current_val)),
      n_age     = sum(!is.na(`Age Group Code`)),
      unk_any   = any(is_unknown)
    ), by = keys]

    cand <- sumdt[has_total == TRUE & n_age > 0 & unk_any == TRUE]
    if (!NROW(cand)) { dt[, is_unknown := NULL]; return(0L) }

    new_count <- 0L

    for (i in seq_len(nrow(cand))) {
      key_row <- cand[i]

      rows <- gdt[
        `Month Code` == key_row[["Month Code"]] &
        geo_type      == key_row[["geo_type"]] &
        geo_code      == key_row[["geo_code"]] &
        (
          (is.na(key_row[["Sex Code"]]) & is.na(`Sex Code`)) |
          (!is.na(key_row[["Sex Code"]]) & `Sex Code` == key_row[["Sex Code"]])
        )
      ]
      if (!NROW(rows)) next

      total_row <- rows[is.na(`Age Group Code`) & !is.na(current_val)]
      age_rows  <- rows[!is.na(`Age Group Code`)]
      if (nrow(total_row) != 1L || !NROW(age_rows)) next

      ids  <- c(total_row$row_id, age_rows$row_id)
      vals <- dt$current_val[ids]
      unks <- dt$is_unknown[ids]

      if (sum(unks) != 1L) next
      if (any(!unks & is.na(vals))) next

      unk_id    <- ids[unks]
      total_val <- total_row$current_val[1]

      if (unk_id == total_row$row_id) {
        candidate <- sum(vals[!unks])
      } else {
        candidate <- total_val - sum(vals[!unks & ids != total_row$row_id])
      }

      if (try_set(unk_id, candidate)) new_count <- new_count + 1L
    }

    dt[, is_unknown := NULL]
    new_count
  }

  ## ---------- Rule: 10-year vs 5-year bands ----------

  deduce_age_5v10 <- function(geo_filter = NULL) {
    dt[, is_unknown := is_unknown_now()]
    gdt <- dt[is_impossible == FALSE]
    if (!is.null(geo_filter)) gdt <- gdt[geo_type == geo_filter]
    if (!NROW(gdt)) { dt[, is_unknown := NULL]; return(0L) }

    keys <- c("Month Code", "geo_type", "geo_code", "Sex Code")
    panels <- gdt[, .(
      any_unknown = any(is_unknown),
      n_age       = sum(!is.na(`Age Group Code`))
    ), by = keys][any_unknown == TRUE & n_age > 0]

    if (!NROW(panels)) { dt[, is_unknown := NULL]; return(0L) }

    new_count <- 0L

    for (i in seq_len(nrow(panels))) {
      key_row <- panels[i]

      rows <- gdt[
        `Month Code` == key_row[["Month Code"]] &
        geo_type      == key_row[["geo_type"]] &
        geo_code      == key_row[["geo_code"]] &
        (
          (is.na(key_row[["Sex Code"]]) & is.na(`Sex Code`)) |
          (!is.na(key_row[["Sex Code"]]) & `Sex Code` == key_row[["Sex Code"]])
        )
      ]
      if (!NROW(rows)) next

      for (ten in names(age_10_to_5)) {
        parts <- age_10_to_5[[ten]]

        row10   <- rows[`Age Group Code` == ten]
        row5set <- rows[`Age Group Code` %chin% parts]

        if (nrow(row10) != 1L) next
        if (nrow(row5set) != length(parts)) next

        ids  <- c(row10$row_id, row5set$row_id)
        vals <- dt$current_val[ids]
        unks <- dt$is_unknown[ids]

        if (sum(unks) != 1L) next
        if (any(!unks & is.na(vals))) next

        unk_id <- ids[unks]

        if (unk_id == row10$row_id) {
          candidate <- sum(vals[!unks])
        } else {
          total_val <- row10$current_val[1]
          if (is.na(total_val)) next
          candidate <- total_val - sum(vals[!unks & ids != row10$row_id])
        }

        if (try_set(unk_id, candidate)) new_count <- new_count + 1L
      }
    }

    dt[, is_unknown := NULL]
    new_count
  }

  ## ---------- Rule: Division from Region ----------
  # For each (Month, Region, Sex, AgeGroup):
  #   if region total is known, and exactly one child division in that slice is unknown,
  #   infer that division as Region - sum(other divisions).

  deduce_div_from_region <- function() {
    dt[, is_unknown := is_unknown_now()]
    reg <- dt[geo_type == "region" & !is.na(current_val)]
    if (!NROW(reg)) { dt[, is_unknown := NULL]; return(0L) }

    new_count <- 0L

    for (i in seq_len(nrow(reg))) {
      rr <- reg[i]
      R  <- rr$geo_code
      mc <- rr$`Month Code`
      sc <- rr$`Sex Code`
      ag <- rr$`Age Group Code`

      child_divs <- region_to_divs[[R]]
      if (is.null(child_divs)) next

      div_rows <- dt[
        geo_type == "division" &
        geo_code %chin% child_divs &
        `Month Code` == mc &
        (
          (is.na(sc) & is.na(`Sex Code`)) |
          (!is.na(sc) & `Sex Code` == sc)
        ) &
        (
          (is.na(ag) & is.na(`Age Group Code`)) |
          (!is.na(ag) & `Age Group Code` == ag)
        ) &
        is_impossible == FALSE
      ]

      if (!NROW(div_rows)) next

      ids  <- div_rows$row_id
      vals <- dt$current_val[ids]
      unks <- dt$is_unknown[ids]

      if (sum(unks) != 1L) next
      if (any(!unks & is.na(vals))) next

      unk_id    <- ids[unks]
      known_sum <- sum(vals[!unks])
      candidate <- rr$current_val - known_sum

      if (try_set(unk_id, candidate)) new_count <- new_count + 1L
    }

    dt[, is_unknown := NULL]
    new_count
  }

  ## ---------- Stage 1: regions first (no region-from-divisions) ----------

  total_supp <- sum(dt$is_suppressed_orig)
  cat("Total suppressed cells:", total_supp, "\n")

  cat("\nStage 1: infer for regions\n")
  for (iter in seq_len(max_region_iter)) {
    before <- sum(dt$is_suppressed_orig & dt$geo_type == "region" & !is.na(dt$current_val))
    cat(" Region Iteration", iter, "\n")

    n1 <- deduce_sex_from_total("region")
    cat("   Region sex totals inferred:", n1, "\n")

    n2 <- deduce_age_total("region")
    cat("   Region age totals inferred:", n2, "\n")

    n3 <- deduce_age_5v10("region")
    cat("   Region 5y-10y inferred:", n3, "\n")

    after <- sum(dt$is_suppressed_orig & dt$geo_type == "region" & !is.na(dt$current_val))
    new_count <- after - before
    cat("   Newly inferred (region) this iter:", new_count,
        " | total region inferred:", after, "\n")

    if (new_count == 0L) {
      cat("   No new regional values. Mark remaining regional suppressed as impossible.\n")
      dt[
        geo_type == "region" &
        is_suppressed_orig == TRUE &
        is.na(current_val),
        is_impossible := TRUE
      ]
      break
    }
  }

  ## ---------- Stage 2: divisions using regions ----------

  cat("\nStage 2: infer for divisions (using cleaned regions)\n")
  for (iter in seq_len(max_division_iter)) {
    before <- sum(dt$is_suppressed_orig & dt$geo_type == "division" & !is.na(dt$current_val))
    cat(" Division Iteration", iter, "\n")

    n1 <- deduce_sex_from_total("division")
    cat("   Division sex totals inferred:", n1, "\n")

    n2 <- deduce_age_total("division")
    cat("   Division age totals inferred:", n2, "\n")

    n3 <- deduce_age_5v10("division")
    cat("   Division 5y-10y inferred:", n3, "\n")

    n4 <- deduce_div_from_region()
    cat("   Division from region inferred:", n4, "\n")

    after <- sum(dt$is_suppressed_orig & dt$geo_type == "division" & !is.na(dt$current_val))
    new_count <- after - before
    cat("   Newly inferred (division) this iter:", new_count,
        " | total division inferred:", after, "\n")

    if (new_count == 0L) {
      cat("   No new divisional values. Mark remaining divisional suppressed as impossible.\n")
      dt[
        geo_type == "division" &
        is_suppressed_orig == TRUE &
        is.na(current_val),
        is_impossible := TRUE
      ]
      break
    }
  }

  ## ---------- Final output ----------

  dt[, Deaths_inferred := ifelse(is_suppressed_orig, current_val, Deaths_num)]
  dt[, was_inferred := is_suppressed_orig & !is.na(Deaths_inferred)]

  cat("\nSummary:\n")
  cat("  Inferred suppressed cells:",
      sum(dt$was_inferred), "out of", total_supp, "\n")
  cat("  Marked impossible:",
      sum(dt$is_suppressed_orig & dt$is_impossible), "\n")

  out <- dt[
    ,
    .(
      `Census Division Code`,
      `Census Region Code`,
      `Month Code`,
      `Sex Code`,
      `Age Group Code`,
      Deaths,
      Deaths_inferred,
      was_inferred,
      is_impossible
    )
  ]

  as.data.frame(out)
}



result <- infer_suppressed_iterative(data_prepared)
result |> write_csv("inferred_data_raw.csv")
```

START HERE
```{r}
## start from the inference result
#res <- as.data.table(result)
res <- fread("inferred_data_raw.csv") |> as.data.table()

## reconstruct geo_type from columns
res[, geo_type := fifelse(!is.na(`Census Division Code`), "division",
                   fifelse(!is.na(`Census Region Code`), "region", NA_character_))]

## define which codes are 10-year (or broader) aggregates
age10_codes <- c(
  "1", "1-4","5-14","15-24","25-34","35-44","45-54",
  "55-64","65-74","75-84","85+", "NS"
)

age5_codes <- c(
  "1", "5-9","15-19","20-24","25-29", "30-34" ,"35-39" ,"40-44", "45-49", "50-54", "55-59" ,"60-64", "65-69" ,"70-74" ,"75-79", "80-84" ,"85-89" ,"90-94" ,"95-99" ,"100+" , "NS"  ,  "1-4"  , "10-14"
)

## keep:
##  - rows grouped by sex (Sex Code not NA)
##  - rows with an age group code that is NOT a 10-year aggregate
##    (this captures the 5-year bands plus "1", "1-4", "NS", etc.,
##     consistent with your stacked structure)
five_by_sex <- res[
  !is.na(`Sex Code`) &
  !is.na(`Age Group Code`) &
  (`Age Group Code` %in% age5_codes)
]

## keep 10-year (and broader) age groups by sex
ten_by_sex <- res[
  !is.na(`Sex Code`) &
  !is.na(`Age Group Code`) &
  (`Age Group Code` %in% age10_codes)
]

## split into division-level and region-level
div_5y_by_sex <- five_by_sex[geo_type == "division"][
  ,
  .(
    `Census Division Code`,
    `Month Code`,
    `Sex Code`,
    `Age Group Code`,
    Deaths,
    Deaths_inferred
  )
]

reg_5y_by_sex <- five_by_sex[geo_type == "region"][
  ,
  .(
    `Census Region Code`,
    `Month Code`,
    `Sex Code`,
    `Age Group Code`,
    Deaths,
    Deaths_inferred
  )
]

## 10-year, by sex
div_10y_by_sex <- ten_by_sex[geo_type == "division"][
  ,
  .(
    `Census Division Code`,
    `Month Code`,
    `Sex Code`,
    `Age Group Code`,
    Deaths,
    Deaths_inferred
  )
]

reg_10y_by_sex <- ten_by_sex[geo_type == "region"][
  ,
  .(
    `Census Region Code`,
    `Month Code`,
    `Sex Code`,
    `Age Group Code`,
    Deaths,
    Deaths_inferred
  )
]

div_5y_by_sex_final <- div_5y_by_sex |> 
  mutate(Deaths = ifelse(Deaths == "Suppressed" & !is.na(Deaths_inferred), Deaths_inferred, Deaths),
         Year = substr(`Month Code`,1,4)) |> 
  select(-Deaths_inferred) |> 
  left_join(Census_Division_Code, by = join_by(`Census Division Code`)) |>
  left_join(Age_Group_Code, by = join_by(`Age Group Code` == `Age Code`))

reg_5y_by_sex_final <- reg_5y_by_sex |> 
  mutate(Deaths = ifelse(Deaths == "Suppressed" & !is.na(Deaths_inferred), Deaths_inferred, Deaths),
         Year = substr(`Month Code`,1,4)) |> 
  select(-Deaths_inferred)|> 
  left_join(Census_Region_Code, by = join_by(`Census Region Code`)) |>
  left_join(Age_Group_Code, by = join_by(`Age Group Code` == `Age Code`))

div_10y_by_sex_final <- div_10y_by_sex |>
  mutate(
    Deaths = ifelse(
      Deaths == "Suppressed" & !is.na(Deaths_inferred),
      Deaths_inferred,
      Deaths
    ),
    Year = substr(`Month Code`, 1, 4)
  ) |>
  select(-Deaths_inferred) |>
  left_join(Census_Division_Code, by = join_by(`Census Division Code`)) |>
  left_join(Age_Group_Code, by = join_by(`Age Group Code` == `Age Code`))

reg_10y_by_sex_final <- reg_10y_by_sex |>
  mutate(
    Deaths = ifelse(
      Deaths == "Suppressed" & !is.na(Deaths_inferred),
      Deaths_inferred,
      Deaths
    ),
    Year = substr(`Month Code`, 1, 4)
  ) |>
  select(-Deaths_inferred) |>
  left_join(Census_Region_Code, by = join_by(`Census Region Code`)) |>
  left_join(Age_Group_Code, by = join_by(`Age Group Code` == `Age Code`))

# 5-year exports

#div_5y_by_sex_final |> write_csv("Inferred-WONDER-Census Division-Sex-5Yr.csv")

#reg_5y_by_sex_final |> write_csv("Inferred-WONDER-Census Region-Sex-5Yr.csv")

# 10-year exports

div_10y_by_sex_final |> write_csv("Inferred-WONDER-Census Division-Sex-10Yr.csv")

reg_10y_by_sex_final |> write_csv("Inferred-WONDER-Census Region-Sex-10Yr.csv")
```


